import { NamingHelper, CSSHelper, ColorFormat, StringCase, FileHelper, ColorHelper } from "@supernovaio/export-helpers"
import { AnyDimensionToken, ColorToken, DimensionToken, GradientToken, ShadowToken, Token, TokenGroup, TokenType } from "@supernovaio/sdk-exporters"
import { ExporterConfiguration } from "config"

export function createRokuVariables(tokens: Token[], tokenGroups: TokenGroup[], themedTokens: Token[]){
// Convert all color tokens to Roku variables
  const mappedTokens = new Map(tokens.map((token) => [token.id, token]))
  const colors = themedTokens
    .filter((t) => t.tokenType === TokenType.color)
    .map((token) => colorTokenToRoku(token as ColorToken, mappedTokens, tokenGroups))

  const dimensions = tokens
    .filter((t) => t.tokenType === TokenType.dimension)
    .map((token) => dimensionTokenToRoku(token as AnyDimensionToken, mappedTokens, tokenGroups))

  const allVariables = colors.concat(dimensions)
    .sort()
    .join('\n')


  // Create CSS file content
  let content = `function Skin()\n  return {\n${allVariables}\n  }\nend function`
  if (exportConfiguration.generateDisclaimer) {
    // Add disclaimer to every file if enabled
    content = `'This file was generated by Supernova, don't change by hand'\n${content}`
  }

  // Create output file and return it
  return content;
}

/** Exporter configuration. Adheres to the `ExporterConfiguration` interface and its content comes from the resolved default configuration + user overrides of various configuration keys */
const exportConfiguration = Pulsar.exportConfig<ExporterConfiguration>()

function colorTokenToRoku(token: ColorToken, mappedTokens: Map<string, Token>, tokenGroups: Array<TokenGroup>): string {
    // First creating the name of the token, using helper function which turns any token name / path into a valid variable name
    const name = tokenVariableName(token, tokenGroups)
    // Then creating the value of the token, using another helper function
    const value = CSSHelper.colorTokenValueToCSS(token.value, mappedTokens, {
      allowReferences: true,
      decimals: 3,
      colorFormat: ColorFormat.smartHashHex,
      tokenToVariableRef: (t) => {
        return `var(--${tokenVariableName(t, tokenGroups)})`
      },
    })
  
    return `    ${name}: "${value}",`
  }

function dimensionTokenToRoku(token: AnyDimensionToken, mappedTokens: Map<string, Token>, tokenGroups: Array<TokenGroup>): string {
  const name = tokenVariableName(token, tokenGroups)
  const value = Math.round(token.value.measure * 100) / 100
  let unit = 'px';
  //console.log(`${name}: ${token.propertyValues["Collection"]}`)
    if (name.includes('letterSpacing') || name.includes('lineHeight') || name.includes('fontWeight')) {
    return `    ${name}: "${value}",`
  } else {
    return `    ${name}: "${value}${unit}",`
  }
}

// Calculates angle of gradient based on the start and end positions
function calculateGradientAngle(from, to) {
  const deltaY = (to.y - from.y);
  const deltaX = (to.x - from.x);
  const radians = Math.atan2(deltaY, deltaX); 
  let result = radians * 180 / Math.PI; 
  result = result + 90; 
  return  ((result < 0) ? (360 + result) : result) % 360;
}

function tokenVariableName(token: Token, tokenGroups: Array<TokenGroup>): string {
    const parent = tokenGroups.find((group) => group.id === token.parentGroupId)!
    return NamingHelper.codeSafeVariableNameForToken(token, StringCase.camelCase, parent, "")
  }