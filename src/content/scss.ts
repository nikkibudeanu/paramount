import { NamingHelper, CSSHelper, ColorFormat, StringCase, FileHelper, ColorHelper } from "@supernovaio/export-helpers"
import { AnyDimensionToken, ElementProperty, ColorToken, GradientToken, ShadowToken, Token, TokenGroup, TokenType } from "@supernovaio/sdk-exporters"
import { ExporterConfiguration } from "config"

export function createSCSSVariables(tokens: Token[], tokenGroups: TokenGroup[]){
// Convert all color tokens to SCSS variables
  const mappedTokens = new Map(tokens.map((token) => [token.id, token]))
  const colors = tokens
    .filter((t) => t.tokenType === TokenType.color)
    .map((token) => colorTokenToSCSS(token as ColorToken, mappedTokens, tokenGroups))

  const shadows = tokens
    .filter((t) => t.tokenType === TokenType.shadow)
    .map((token) => shadowTokenToSCSS(token as ShadowToken, mappedTokens, tokenGroups))

  const gradients = tokens
    .filter((t) => t.tokenType === TokenType.gradient)
    .map((token) => gradientTokensToSCSS(token as GradientToken, mappedTokens, tokenGroups))

  const dimensions = tokens
    .filter((t) => t.tokenType === TokenType.dimension)
    .map((token) => dimensionTokenToSCSS(token as AnyDimensionToken, mappedTokens, tokenGroups))

  const allVariables = colors.concat(shadows, gradients, dimensions)
    .sort()
    .join('\n')

  // Create CSS file content
  let content = `${allVariables}`
  if (exportConfiguration.generateDisclaimer) {
    // Add disclaimer to every file if enabled
    content = `//This file was generated by Supernova, don't change by hand\n${content}`
  }

  // Create output file and return it
  return content;
}

function dimensionTokenToSCSS(token: AnyDimensionToken, mappedTokens: Map<string, Token>, tokenGroups: Array<TokenGroup>): string {
  const name = tokenVariableName(token, tokenGroups)
  const value = Math.round(token.value.measure * 100) / 100
  let unit = 'px';
  //console.log(`${name}: ${token.propertyValues["Collection"]}`)
  if (name.includes('letter-spacing') || name.includes('line-height') || name.includes('font-weight')) {
    return `$${name}: ${value};`
  } else {
    return `$${name}: ${value}${unit};`
  }
}

/** Exporter configuration. Adheres to the `ExporterConfiguration` interface and its content comes from the resolved default configuration + user overrides of various configuration keys */
const exportConfiguration = Pulsar.exportConfig<ExporterConfiguration>()

function colorTokenToSCSS(token: ColorToken, mappedTokens: Map<string, Token>, tokenGroups: Array<TokenGroup>): string {
    // First creating the name of the token, using helper function which turns any token name / path into a valid variable name
    const name = tokenVariableName(token, tokenGroups)
  
    // Then creating the value of the token, using another helper function
    const value = CSSHelper.colorTokenValueToCSS(token.value, mappedTokens, {
      allowReferences: true,
      decimals: 3,
      colorFormat: ColorFormat.hex8,
      tokenToVariableRef: (t) => {
        return `var(--${tokenVariableName(t, tokenGroups)})`
      },
    })
  
    return `$${name}: "${value}";`
  }

function tokenVariableName(token: Token, tokenGroups: Array<TokenGroup>): string {
    const parent = tokenGroups.find((group) => group.id === token.parentGroupId)!
    return NamingHelper.codeSafeVariableNameForToken(token, StringCase.paramCase, parent, "")
  }

// Shadow tokens
function shadowTokenToSCSS(token: ShadowToken, mappedTokens: Map<string, Token>, tokenGroups: Array<TokenGroup>): string {
  const name = tokenVariableName(token, tokenGroups)
  const shadowValue = token.value[0]
  const x = shadowValue.x
  const y = shadowValue.y
  const radius = shadowValue.radius
  const spread = shadowValue.spread
  const color = shadowValue.color.color
  const r = color.r
  const g = color.g
  const b = color.b
  const opacity = Math.round(shadowValue.opacity.measure * 100) / 100
  const value = `${x}px ${y}px ${radius}px ${spread}px rgba(${r}, ${g}, ${b}, ${opacity})`
  return `$${name}: ${value};`
}

// Gradient tokens
function gradientTokensToSCSS(token: GradientToken, mappedTokens: Map<string, Token>, tokenGroups: Array<TokenGroup>): string {
  const name = tokenVariableName(token, tokenGroups)
  const degree = `${calculateGradientAngle(token.value[0].from, token.value[0].to)}deg`
  let stops = token.value[0].stops
    .map((stop) => {
      return `${CSSHelper.colorTokenValueToCSS(stop.color, mappedTokens, {
        allowReferences: false,
        decimals: 2,
        colorFormat: ColorFormat.rgba,
        tokenToVariableRef: function (token: Token): string {
          throw new Error("Function not implemented.");
        }
      })} ${ColorHelper.roundToDecimals(
        stop.position * 100,
        2
      )}%`
    })
    .join(', ')
  const value = `linear-gradient(${degree}, ${stops})`
  return `$${name}: ${value};`
}

// Calculates angle of gradient based on the start and end positions
function calculateGradientAngle(from, to) {
  const deltaY = (to.y - from.y);
  const deltaX = (to.x - from.x);
  const radians = Math.atan2(deltaY, deltaX); 
  let result = radians * 180 / Math.PI; 
  result = result + 90; 
  return  ((result < 0) ? (360 + result) : result) % 360;
}